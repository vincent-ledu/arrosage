{% extends "base.html" %} {% block title %}{{ _('Watering') }}{% endblock %} {%
block content %}
<h2>{{ _('Auto watering') }}</h2>
<div class="container">
  <div class="tank-container">
    <div class="tank">
      <div class="water" id="water-fill" style="height: 0%"></div>
      <div class="level-label" id="level-label">--%</div>
    </div>
  </div>
  <section>
    <table id="forecast-table-condensed">
      <thead>
        <tr id="forecast-days"></tr>
      </thead>
      <tbody>
        <tr id="forecast-forecast"></tr>
        <tr id="forecast-minmax"></tr>
        <tr id="forecast-rain"></tr>
        <tr id="forecast-watering"></tr>
      </tbody>
    </table>
  </section>

  <button onclick="getLevel()">{{ _('Refresh levels')}}</button>

  <div style="margin-top: 10px">
    <input
      type="number"
      id="duration"
      placeholder="Dur√©e (s)"
      min="1"
      style="width: 100%; padding: 10px; font-size: 16px"
    />
  </div>
  <button id="open-btn" onclick="startOpenWater()">{{ _('Watering') }}</button>

  <button id="close-btn" onclick="stopOpenWater()">
    {{ _('Stop watering') }}
  </button>
  <div id="message"></div>
  <div id="status-info"></div>
  <div id="progress-container">
    <div id="progress-bar"></div>
  </div>
</div>

<script>
  const watering = {
    low: "S",
    moderate: "M",
    standard: "L",
    reinforced: "XL",
    high: "XXL",
  };
  function getTemperatureWatering() {
    fetch("/api/temperature-max")
      .then((res) => res.text())
      .then((temp) => {
        if (temp !== undefined) {
          document.getElementById(
            "temperature-max"
          ).textContent = `üå°Ô∏è: ${Math.floor(temp)}¬∞C`;
          getWatering(temp);
        } else {
          document.getElementById(
            "temperature-max"
          ).textContent = `{{ _('Error: Unable to retrieve temperature') }}`;
        }
      });
  }
  async function getWatering(temp) {
    return fetch(`/api/watering-type?temp=${temp}`).then((res) => {
      if (res.ok) {
        return res.text().then((wateringType) => {
          console.log("Watering type:", wateringType);
          return watering[wateringType];
        });
      }
    });
  }
  function getLevel() {
    fetch("/api/water-level")
      .then((res) => res.json())
      .then((data) => {
        if (data.level !== undefined) {
          const level = data.level;
          const waterFill = document.getElementById("water-fill");
          const levelLabel = document.getElementById("level-label");

          waterFill.style.height = `${level}%`;
          levelLabel.textContent = `${level}%`;
        } else {
          document.getElementById("level").textContent =
            "{{ _('Error: Unable to retrieve water level') }}";
        }
      });
  }
  async function startOpenWater() {
    const duration = parseInt(document.getElementById("duration").value);
    if (!duration || duration <= 0 || duration > 300) {
      alert(
        "{{ _('Please enter a valid duration between 1 and 300 seconds') }}"
      );
      return;
    }
    const button = document.getElementById("open-btn");
    button.disabled = true;
    document.getElementById("close-btn").disabled = false;

    const response = await fetch(
      `/api/command/open-water?duration=${duration}`
    );
    const data = await response.json();
    currentTaskId = data.task_id;
    checkStatus();

    intervalCheck = setInterval(() => {
      checkStatus();
    }, 3000);
  }

  async function checkStatus() {
    if (!currentTaskId) return;

    const response = await fetch(`/api/tasks/${currentTaskId}`);
    const data = await response.json();

    const statusText = {
      "in progress": "{{ _('Watering in progress') }}",
      completed: "{{ _('Watering completed') }}",
      canceled: "{{ _('Watering canceled') }}",
    };

    console.log("Task data:", data);

    document.getElementById("message").textContent =
      statusText[data.status] || data.status;

    const progressContainer = document.getElementById("progress-container");
    const progressBar = document.getElementById("progress-bar");

    if (data.status === "in progress") {
      const now = Math.floor(Date.now() / 1000);
      const elapsed =
        now - Math.floor(new Date(data.created_at).getTime() / 1000);
      const remaining = Math.max(0, data.duration - elapsed);
      const percent = Math.min(100, (elapsed / data.duration) * 100);

      document.getElementById(
        "status-info"
      ).textContent = `{{ _('Started at:') }} ${data.created_at} ‚Äî {{ _('Time remaining') }} ${remaining}s`;

      progressBar.style.width = percent + "%";
      progressContainer.style.display = "block";
    } else {
      document.getElementById("open-btn").disabled = false;
      document.getElementById("close-btn").disabled = true;
      clearInterval(intervalCheck);
      currentTaskId = null;
      document.getElementById("status-info").textContent = "";
      progressContainer.style.display = "none";
      progressBar.style.width = "0%";
    }
  }

  async function stopOpenWater() {
    const response = await fetch("/api/command/close-water");
    const data = await response.json();
    document.getElementById("message").textContent = data.message;
    document.getElementById("open-btn").disabled = false;
    document.getElementById("close-btn").disabled = true;
    clearInterval(intervalCheck);
    document.getElementById("status-info").textContent = "";
  }

  async function loadForecast() {
    try {
      const response = await fetch("/api/forecast");
      const data = await response.json();

      if (data.error) {
        document.querySelector("#forecast-table-condensed").outerHTML =
          "<p>Erreur m√©t√©o : " + data.error + "</p>";
        return;
      }

      const daysRow = ["<th>&nbsp;</th>"];
      const forecastRow = ["<td>‚òÅÔ∏è/‚òÄÔ∏è-üå°Ô∏è</td>"];
      const minmaxRow = ["<td>‚ùÑÔ∏è<br>üî•</td>"];
      const rainRow = ["<td>üåßÔ∏èmm</td>"];
      const wateringRow = ["<td>üöø</td>"];

      for (let i = 0; i < data.length; i++) {
        const dayLabel = i == 0 ? "J" : `J+${i}`;
        const forecast = `${data[i].night_icon} ${Math.floor(
          data[i].night_temp_avg
        )}<br>${data[i].morning_icon} ${Math.floor(
          data[i].morning_temp_avg
        )}<br>${data[i].afternoon_icon} ${Math.floor(
          data[i].afternoon_temp_avg
        )}<br>${data[i].evening_icon} ${Math.floor(data[i].evening_temp_avg)}`;
        const minmax = `${Math.ceil(data[i].temp_min)}¬∞C<br>${Math.floor(
          data[i].temp_max
        )}¬∞C`;
        const rain =
          Math.round(
            (
              data[i].night_precip_mm +
              data[i].morning_precip_mm +
              data[i].afternoon_precip_mm +
              data[i].evening_precip_mm
            ).toFixed(1) * 10
          ) / 10;
        const watering = await getWatering(data[i].afternoon_temp_avg);

        daysRow.push(`<th>${dayLabel}</th>`);
        forecastRow.push(`<td>${forecast}</td>`);
        minmaxRow.push(`<td>${minmax}</td>`);
        rainRow.push(`<td>${rain}</td>`);
        wateringRow.push(`<td>${watering}</td>`);
      }

      document.getElementById("forecast-days").innerHTML = daysRow.join("");
      document.getElementById("forecast-forecast").innerHTML =
        forecastRow.join("");
      document.getElementById("forecast-minmax").innerHTML = minmaxRow.join("");
      document.getElementById("forecast-rain").innerHTML = rainRow.join("");
      document.getElementById("forecast-watering").innerHTML =
        wateringRow.join("");
    } catch (e) {
      document.querySelector("#forecast-table-condensed").outerHTML =
        "<p>Erreur m√©t√©o (chargement JS).</p>";
    }
  }

  window.addEventListener("DOMContentLoaded", loadForecast);

  window.onload = () => {
    getLevel();
    //getTemperatureWatering();
    document.getElementById("open-btn").disabled = false;
    document.getElementById("close-btn").disabled = true;
  };
</script>
{% endblock %}
